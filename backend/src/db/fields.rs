use crate::{
    db,
    model::{Field, FieldOptions},
    Id,
};
use sqlx::{types::Json, Acquire, FromRow, PgExecutor, Postgres};
use std::collections::HashMap;

#[derive(FromRow)]
pub struct FieldIdentifier {
    data_table_name: String,
    data_field_name: String,
}

pub async fn create_field(
    connection: impl Acquire<'_, Database = Postgres>,
    table_id: Id,
    name: String,
    options: FieldOptions,
) -> sqlx::Result<Id> {
    let mut tx = connection.begin().await?;

    let (field_id, data_field_name): (Id, String) = sqlx::query_as(
        r#"
            INSERT INTO meta_field (table_id, name, options)
            VALUES ($1, $2, $3)
            RETURNING field_id, data_field_name
        "#,
    )
    .bind(table_id)
    .bind(name)
    .bind(sqlx::types::Json(options.clone()))
    .fetch_one(tx.as_mut())
    .await?;

    let column_type = match options {
        FieldOptions::Text { .. } => "TEXT",
        FieldOptions::Integer { .. } => "BIGINT",
        FieldOptions::Decimal { .. } => "DOUBLE",
        FieldOptions::Money { .. } => "numeric_money",
        FieldOptions::Progress { .. } => "INT NOT NULL DEFAULT 0",
        FieldOptions::DateTime { .. } => "TIMESTAMPTZ",
        FieldOptions::Interval { .. } => "INTERVAL",
        FieldOptions::WebLink { .. } => "COLLATE case_insensitive TEXT",
        FieldOptions::Email { .. } => "COLLATE case_insensitive TEXT",
        FieldOptions::Checkbox => "BOOLEAN NOT NULL DEFAULT FALSE",
        FieldOptions::Enumeration { .. } => "INT",
        FieldOptions::Image { .. } => todo!("Not implemented"),
        FieldOptions::File { .. } => todo!("Not implemented"),
    };

    let data_table_name = db::get_data_table_name(tx.as_mut(), table_id).await?;

    // data_table_name and data_field_name generated by database NO INJECTION POSSIBLE
    sqlx::query(&format!(
        r#"
            ALTER TABLE {data_table_name}
            ADD COLUMN {data_field_name} {column_type}
        "#,
    ))
    .execute(tx.as_mut())
    .await?;

    tx.commit().await?;
    return Ok(field_id);
}

pub async fn update_field(
    connection: impl Acquire<'_, Database = Postgres>,
    field_id: Id,
    name: String,
    option: FieldOptions,
) -> sqlx::Result<()> {
    todo!()
}

pub async fn delete_field(
    connection: impl Acquire<'_, Database = Postgres>,
    field_id: Id,
) -> sqlx::Result<()> {
    let mut tx = connection.begin().await?;

    let FieldIdentifier {
        data_table_name,
        data_field_name,
    } = get_field_identifier(tx.as_mut(), field_id).await?;

    sqlx::query(&format!(
        r#"
            ALTER TABLE {data_table_name}
            DROP COLUMN {data_field_name} CASCADE
        "#,
    ))
    .execute(tx.as_mut())
    .await?;

    tx.commit().await?;
    Ok(())
}

pub async fn get_fields(executor: impl PgExecutor<'_>, table_id: Id) -> sqlx::Result<Vec<Field>> {
    Ok(sqlx::query_as(
        r#"
            SELECT
                field_id,
                table_id,
                name,
                options,
                created_at,
                updated_at
            FROM meta_field
            WHERE table_id = $1
            FOR UPDATE
        "#,
    )
    .bind(table_id)
    .fetch_all(executor)
    .await?)
}

pub async fn get_field(executor: impl PgExecutor<'_>, field_id: Id) -> sqlx::Result<Option<Field>> {
    Ok(sqlx::query_as(
        r#"
            SELECT
                field_id,
                table_id,
                name,
                options,
                created_at,
                updated_at
            FROM meta_field
            WHERE field_id = $1
            FOR UPDATE
        "#,
    )
    .bind(field_id)
    .fetch_optional(executor)
    .await?)
}

pub async fn get_field_table_id(
    executor: impl PgExecutor<'_>,
    field_id: Id,
) -> sqlx::Result<Option<Id>> {
    Ok(sqlx::query_as::<_, (_,)>(
        r#"
            SELECT table_id
            FROM meta_field
            WHERE field_id = $1
            FOR UPDATE
        "#,
    )
    .bind(field_id)
    .fetch_optional(executor)
    .await?
    .map(|x| x.0))
}

pub async fn get_field_identifier(
    executor: impl PgExecutor<'_>,
    field_id: Id,
) -> sqlx::Result<FieldIdentifier> {
    Ok(sqlx::query_as(
        r#"
            SELECT data_table_name, data_field_name
            FROM meta_table AS t
            JOIN meta_field AS f
            ON f.table_id = t.table_id
            WHERE field_id = $1
            FOR UPDATE
        "#,
    )
    .bind(field_id)
    .fetch_one(executor)
    .await?)
}

pub async fn get_fields_options(
    executor: impl PgExecutor<'_>,
    table_id: Id,
) -> sqlx::Result<HashMap<Id, FieldOptions>> {
    Ok(sqlx::query_as::<_, (Id, Json<FieldOptions>)>(
        r#"
            SELECT field_id, options
            FROM meta_field
            WHERE table_id = $1
            FOR UPDATE
        "#,
    )
    .bind(table_id)
    .fetch_all(executor)
    .await?
    .into_iter()
    .map(|(field_id, options)| (field_id, options.0))
    .collect())
}

pub async fn get_data_field_names(
    executor: impl PgExecutor<'_>,
    table_id: Id,
) -> sqlx::Result<HashMap<Id, String>> {
    Ok(sqlx::query_as::<_, (Id, String)>(
        r#"
            SELECT field_id, data_field_name
            FROM meta_field
            WHERE table_id = $1
            FOR UPDATE
        "#,
    )
    .bind(table_id)
    .fetch_all(executor)
    .await?
    .into_iter()
    .collect())
}

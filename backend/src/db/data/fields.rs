use crate::{
    model::data::{Field, FieldOptions, FullField},
    Id,
};
use sqlx::{types::Json, Acquire, FromRow, PgExecutor, Postgres};
use std::{collections::HashMap, mem::discriminant};

use super::Relation;

#[derive(FromRow)]
pub struct FieldIdentifier {
    data_table_name: String,
    data_field_name: String,
}

pub async fn create_field(
    connection: impl Acquire<'_, Database = Postgres>,
    table_id: Id,
    name: String,
    options: FieldOptions,
) -> sqlx::Result<Field> {
    let mut tx = connection.begin().await?;

    let FullField {
        field,
        data_field_name,
    } = sqlx::query_as(
        r#"
            INSERT INTO meta_field (table_id, name, options)
            VALUES ($1, $2, $3)
            RETURNING
                field_id,
                table_id,
                name,
                options,
                created_at,
                updated_at,
                data_field_name
        "#,
    )
    .bind(table_id)
    .bind(name)
    .bind(sqlx::types::Json(options.clone()))
    .fetch_one(tx.as_mut())
    .await?;

    let data_table_name: String = sqlx::query_scalar(
        r#"
            SELECT data_table_name
            FROM meta_table
            WHERE table_id = $1
        "#,
    )
    .bind(table_id)
    .fetch_one(tx.as_mut())
    .await?;

    let column_type = match options {
        FieldOptions::Text { .. } => "TEXT",
        FieldOptions::Integer { .. } => "BIGINT",
        FieldOptions::Decimal { .. } => "DOUBLE",
        FieldOptions::Money { .. } => "numeric_money",
        FieldOptions::Progress { .. } => "BIGINT NOT NULL DEFAULT 0",
        FieldOptions::DateTime { .. } => "TIMESTAMPTZ",
        FieldOptions::Interval { .. } => "INTERVAL",
        FieldOptions::WebLink { .. } => "COLLATE case_insensitive TEXT",
        FieldOptions::Email { .. } => "COLLATE case_insensitive TEXT",
        FieldOptions::Checkbox => "BOOLEAN NOT NULL DEFAULT FALSE",
        FieldOptions::Enumeration { .. } => "BIGINT",
    };

    // data_table_name and data_field_name generated by database NO INJECTION POSSIBLE
    sqlx::query(&format!(
        r#"
            ALTER TABLE {data_table_name}
            ADD COLUMN {data_field_name} {column_type}
        "#,
    ))
    .execute(tx.as_mut())
    .await?;

    tx.commit().await?;

    return Ok(field);
}

pub async fn update_field(
    connection: impl Acquire<'_, Database = Postgres>,
    field_id: Id,
    name: String,
    options: FieldOptions,
) -> sqlx::Result<Field> {
    let mut tx = connection.begin().await?;

    let Json(old_options): Json<FieldOptions> = sqlx::query_scalar(
        r#"
            SELECT options
            FROM meta_field
            WHERE field_id = $1
        "#,
    )
    .bind(field_id)
    .fetch_one(tx.as_mut())
    .await?;

    // Should create a new field and attempt to convert
    if discriminant(&options) != discriminant(&old_options) {
        todo!("Not implemented")
    }

    let field: Field = sqlx::query_as(
        r#"
            UPDATE meta_field
            SET name = $1, options = $2
            WHERE field_id = $3
            RETURNING
                field_id,
                table_id,
                name,
                options,
                created_at,
                updated_at
        "#,
    )
    .bind(name)
    .bind(Json(options))
    .bind(field_id)
    .fetch_one(tx.as_mut())
    .await?;

    tx.commit().await?;

    Ok(field)
}

pub async fn delete_field(
    connection: impl Acquire<'_, Database = Postgres>,
    field_id: Id,
) -> sqlx::Result<()> {
    let mut tx = connection.begin().await?;

    let data_table_name: String = sqlx::query_scalar(
        r#"
            SELECT data_table_name
            FROM meta_table AS t
            JOIN meta_field AS f
            ON t.table_id = f.table_id
            WHERE field_id = $1
        "#,
    )
    .bind(field_id)
    .fetch_one(tx.as_mut())
    .await?;

    let data_field_name: String = sqlx::query_scalar(
        r#"
            DELETE FROM meta_field
            WHERE field_id = $1
            RETURNING data_field_name
        "#,
    )
    .bind(field_id)
    .fetch_one(tx.as_mut())
    .await?;

    sqlx::query(&format!(
        r#"
            ALTER TABLE {data_table_name}
            DROP COLUMN {data_field_name} CASCADE
        "#,
    ))
    .execute(tx.as_mut())
    .await?;

    tx.commit().await?;

    Ok(())
}

pub async fn get_fields(executor: impl PgExecutor<'_>, table_id: Id) -> sqlx::Result<Vec<Field>> {
    sqlx::query_as(
        r#"
            SELECT
                field_id,
                table_id,
                name,
                options,
                created_at,
                updated_at
            FROM meta_field
            WHERE table_id = $1
        "#,
    )
    .bind(table_id)
    .fetch_all(executor)
    .await
}

pub async fn get_fields_options(
    executor: impl PgExecutor<'_>,
    table_id: Id,
) -> sqlx::Result<HashMap<Id, FieldOptions>> {
    sqlx::query_as::<_, (Id, Json<FieldOptions>)>(
        r#"
            SELECT field_id, options
            FROM meta_field
            WHERE table_id = $1
        "#,
    )
    .bind(table_id)
    .fetch_all(executor)
    .await
    .map(|x| {
        x.into_iter()
            .map(|(field_id, options)| (field_id, options.0))
            .collect()
    })
}

pub async fn check_field_relation(
    executor: impl PgExecutor<'_>,
    table_id: Id,
    field_id: Id,
) -> sqlx::Result<Relation> {
    sqlx::query_scalar::<_, Id>(
        r#"
            SELECT table_id
            FROM meta_field
            WHERE field_id = $1
        "#,
    )
    .bind(field_id)
    .fetch_optional(executor)
    .await
    .map(|id| match id {
        None => Relation::Absent,
        Some(id) if id == table_id => Relation::Owned,
        Some(_) => Relation::NotOwned,
    })
}

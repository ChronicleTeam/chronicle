use super::ApiState;
use crate::{
    api::error::{ApiError, ApiResult, OnConstraint},
    Id,
};
use axum::{extract::State, routing::post, Json, Router};
use axum_macros::debug_handler;
use chrono::{DateTime, Utc};
use serde::{Deserialize, Serialize};
use sqlx::{prelude::*, PgPool};

pub(crate) fn router() -> Router<ApiState> {
    Router::new().nest(
        "/tables",
        Router::new().route("/", post(create_table).get(get_all_tables)),
    )
}

// DTOs

#[derive(Serialize)]
struct Table {
    table_id: Id,
    name: String,
    description: String,
    created_at: DateTime<Utc>,
    updated_at: Option<DateTime<Utc>>,
}

#[derive(Serialize)]
struct TableId {
    table_id: Id,
}

#[derive(Deserialize)]
struct CreateTable {
    name: String,
    description: String,
}

#[derive(Deserialize, FromRow)]
struct InsertTable {
    table_id: Id,
    data_table_name: String,
}

// Route handlers

// #[debug_handler]
async fn create_table(
    State(ApiState { pool, .. }): State<ApiState>,
    Json(create_table): Json<CreateTable>,
) -> ApiResult<Json<TableId>> {
    // TESTING
    let user_id = debug_get_user_id(&pool).await?;

    let InsertTable {
        table_id,
        data_table_name,
    } = sqlx::query_as(
        r#"
            INSERT INTO table_metadata (user_id, name, description)
            VALUES ($1, $2, $3) 
            RETURNING table_id, data_table_name
        "#,
    )
    .bind(user_id)
    .bind(create_table.name)
    .bind(create_table.description)
    .fetch_one(&pool)
    .await
    .on_constraint("table_metadata_user_id_name_key", |_| {
        ApiError::unprocessable_entity([("table", "table name already used")])
    })?;

    // generate data table

    // data_table_name generated by database NO INJECTION POSSIBLE
    sqlx::query(&format!(
        r#"
            CREATE TABLE {data_table_name} (
                created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
                updated_at TIMESTAMPTZ,
            )
        "#,
    ))
    .execute(&pool)
    .await?;

    sqlx::query(&format!(
        r#"SELECT trigger_updated_at('{data_table_name}');"#,
    ))
    .execute(&pool)
    .await?;

    Ok(Json(TableId { table_id }))
}

#[debug_handler]
async fn get_all_tables(
    State(ApiState { pool, .. }): State<ApiState>,
) -> ApiResult<Json<Vec<Table>>> {
    todo!("Not implemented")
}

async fn debug_get_user_id(pool: &PgPool) -> Result<Id, sqlx::Error> {
    Ok(sqlx::query("SELECT user_id FROM app_user LIMIT 1;")
        .fetch_one(pool)
        .await?
        .get("user_id"))
}

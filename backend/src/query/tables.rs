use crate::{
    error::{ApiError, ApiResult, OnConstraint},
    Id,
};
use sqlx::{prelude::*, PgExecutor, Postgres};

#[derive(FromRow)]
struct InsertTable {
    table_id: Id,
    data_table_name: String,
}

#[derive(FromRow)]
struct SelectDataTableName {
    data_table_name: String,
}

pub async fn insert_table(
    conn: impl Acquire<'_, Database = Postgres>,
    user_id: Id,
    name: String,
    description: String,
) -> ApiResult<Id> {

    let mut transaction = conn.begin().await?;

    let InsertTable {
        table_id,
        data_table_name,
    } = sqlx::query_as(
        r#"
            INSERT INTO table_metadata (user_id, name, description)
            VALUES ($1, $2, $3) 
            RETURNING table_id, data_table_name
        "#,
    )
    .bind(user_id)
    .bind(name)
    .bind(description)
    .fetch_one(transaction.as_mut())
    .await
    .on_constraint("table_metadata_user_id_name_key", |_| {
        ApiError::unprocessable_entity([("table", "table name already used")])
    })?;

    // data_table_name generated by database NO INJECTION POSSIBLE

    sqlx::query(&format!(
        r#"
            CREATE TABLE {data_table_name} (
                created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
                updated_at TIMESTAMPTZ,
            )
        "#,
    ))
    .execute(transaction.as_mut())
    .await?;

    sqlx::query(&format!(
        r#"SELECT trigger_updated_at('{data_table_name}')"#,
    ))
    .execute(transaction.as_mut())
    .await?;

    transaction.commit();

    Ok(table_id)
}

pub async fn get_data_table_name(executor: impl PgExecutor<'_>, table_id: Id) -> ApiResult<String> {
    let SelectDataTableName { data_table_name } = sqlx::query_as(
        r#"
            SELECT data_table_name
            FROM table_metadata
            WHERE table_id = $1
        "#,
    )
    .bind(table_id)
    .fetch_one(executor)
    .await?;
    Ok(data_table_name)
}
